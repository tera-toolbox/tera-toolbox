const net = require('net');
const path = require('path');
const EventEmitter = require('events');
const ModuleManager = require('./moduleManager');
const GPKManager = require('./GPKManager');

class TeraClientInterfaceConnection extends EventEmitter {
    constructor(socket, moduleFolder, GPKManager) {
        super();
        this.setMaxListeners(0);

        this.socket = socket;
        this.buffer = null;

        this.dataQueryEventEmitter = new EventEmitter;
        this.nextDataQueryId = 0;

        this.moduleManager = new ModuleManager(this, moduleFolder);
        this.GPKManager = GPKManager;

        this.canInstallGPKs = false;

        this.socket.on('data', data => {
            this.buffer = this.buffer ? Buffer.concat([this.buffer, data]) : data;

            let start = 0;
            let end = -1;
            while ((end = this.buffer.indexOf(0, start)) >= 0) {
                if (end > start) {
                    const packet = this.buffer.slice(start, end);
                    try {
                        const parsed = JSON.parse(packet);
                        switch (parsed.command) {
                            case 'dcresult':
                                this.dataQueryEventEmitter.emit(parsed.data["id"].toString(), parsed.data);
                                break;
                            case 'ready':
                                this.emit('data', parsed.command, parsed.data || {});
                                this.emit('ready');
                                break;
                            default:
                                this.emit('data', parsed.command, parsed.data || {});
                                break;
                        }
                    } catch (e) {
                        console.log(`[toolbox] Error communicating with client:`);
                        console.log(e);
                    }
                }

                start = end + 1;
            }

            this.buffer = this.buffer.slice(start);
        });

        this.socket.once('error', e => {
            this.emit('disconnect', e);
            this._onClose();
            this.socket = null;
        });

        this.socket.once('close', () => {
            this.emit('disconnect');
            this._onClose();
            this.socket = null;
        });
    }

    send(command, data = {}) {
        if (this.socket)
            this.socket.write(JSON.stringify({ command, data }) + "\x00");
    }

    _onClose() {
        this.removeAllListeners();

        if (this.moduleManager) {
            this.moduleManager.destructor();
            this.moduleManager = null;
        }

        if (this.GPKManager && this.info && this.info.path)
            this.GPKManager.uninstallAll(path.join(this.info.path, '..'));
        this.GPKManager = null;

        if (this.dataQueryEventEmitter) {
            this.dataQueryEventEmitter.removeAllListeners();
            this.dataQueryEventEmitter = null;
        }
    }

    destructor() {
        if (this.socket) {
            this.socket.end();
            this.socket.destroy();
            this.socket = null;
        } else {
            this._onClose();
        }
    }

    queryData(query, queryArgs = null, findAll = false, children = true, attributeFilter = null) {
        const queryId = this.nextDataQueryId++;

        const res = new Promise((resolve, reject) => {
            this.dataQueryEventEmitter.once(queryId.toString(), result => {
                if (result.success)
                    resolve(result.data);
                else
                    reject(result.error);
            });
        });

        this.send('dcquery', {
            id: queryId,
            query: query,
            arguments: queryArgs,
            findall: findAll,
            children: children,
            attributeFilter: attributeFilter,
        });

        return res;
    }

    flashWindow(count = 5, interval = 0, allowFocused = false) {
        if (typeof (count) !== 'number')
            throw new Error('Count must be a number!');
        if (typeof (interval) !== 'number')
            throw new Error('Interval must be a number!');
        if (typeof (allowFocused) !== 'boolean')
            throw new Error('AllowFocused must be a boolean!');

        this.send('flashwindow', { count, interval, allowFocused });
    }

    configureCameraShake(enabled, power = 1.0, speed = 1.0) {
        if (typeof (enabled) !== 'boolean')
            throw new Error('Enabled must be a boolean!');
        if (typeof (power) !== 'number')
            throw new Error('Power must be a number!');
        if (typeof (speed) !== 'number')
            throw new Error('Speed must be a number!');

        this.send('camerashake', { enabled, power, speed });
    }

    suspend() {
        this.send('suspend', {});
    }

    resume() {
        this.send('resume', {});
    }

    installGPK(fromPath, filename = null) {
        if (!this.canInstallGPKs)
            return;

        if (!filename)
            filename = path.basename(fromPath);
        this.GPKManager.install(path.join(this.info.path, '..'), filename, fromPath);
    }
}

class TeraClientInterfaceServer {
    constructor(host, port, moduleFolder, onAccept, onReady, onError) {
        this.host = host;
        this.port = port;
        this.moduleFolder = moduleFolder;
        this.onAccept = onAccept;

        this.GPKManager = new GPKManager('_TERAToolbox');

        this.connections = new Set;

        this.server = net.createServer(socket => this.accept(socket));
        this.server.on('listening', () => onReady());
        this.server.on('error', e => onError(e));

        if (process.platform === 'win32') {
            const ProcessListenerDLLInjector = require('./process-listener-dll-injector');
            this.processListener = new ProcessListenerDLLInjector(100);
        } else {
            this.processListener = null;
        }
    }

    destructor() {
        if (this.processListener) {
            this.processListener.destructor();
            this.processListener = null;
        }

        this.connections.forEach(connection => connection.destructor());
        this.connections.clear();

        this.server.close();
        this.server = null;

        if (this.GPKManager) {
            this.GPKManager.destructor();
            this.GPKManager = null;
        }

        this.onAccept = null;
    }

    run() {
        this.server.listen(this.port, this.host);
        if (this.processListener)
            this.processListener.run();
    }

    accept(socket) {
        socket.setNoDelay(true);

        const connection = new TeraClientInterfaceConnection(socket, this.moduleFolder, this.GPKManager);
        this.connections.add(connection);
        socket.once('error', () => this.onDisconnect(connection));
        socket.once('close', () => this.onDisconnect(connection));

        this.onAccept(connection);
        if (this.processListener)
            this.processListener.setInterval(1000);
    }

    onDisconnect(connection) {
        this.connections.delete(connection);
        if (this.processListener)
            this.processListener.setInterval(this.connections.size > 0 ? 1000 : 100);
    }
}

module.exports = TeraClientInterfaceServer;
